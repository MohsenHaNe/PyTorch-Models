# -*- coding: utf-8 -*-
"""LeNet model

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Po5ZbljESPtM_ixsgpqvpl5bKuOY3m9q
"""

import torch
from torch import nn
from torch.nn import Module
from torch.nn import functional as F
from torchinfo import summary
import torch.optim as opt

class LeNet(Module):
  def __init__(self,output_dim):
    super().__init__()
    self.cl1 = nn.Conv2d(in_channels=1,out_channels=6,kernel_size=5)
    self.cl2 = nn.Conv2d(in_channels=6,out_channels=16,kernel_size=5)
    self.fl1= nn.Linear(in_features=16*5*5 , out_features=120)
    self.fl2= nn.Linear(in_features=120 , out_features=84)
    self.fl3= nn.Linear(in_features=84 , out_features=output_dim)


  def forward(self,x):
    # Feature Extraction
    x = self.cl1(x)
    x = F.max_pool2d(x,kernel_size=2)
    x = F.relu(x)
    x = self.cl2(x)
    x = F.max_pool2d(x,kernel_size=2)
    x = F.relu(x)
    # Flatten
    x = x.view(-1, 16*5*5)
    # Classification
    x = self.fl1(x)
    x = self.F.relu(x)
    x = self.fl2(x)
    x = self.F.relu(x)
    x = self.fl3(x)
    return x

out_class = 10 # CIFAR10
model = LeNet(output_dim=out_class)

summary(model)

lr = 0.001
optimizer = opt.SGD(model.parameters(),lr=lr)
criterion = nn.CrossEntropyLoss()